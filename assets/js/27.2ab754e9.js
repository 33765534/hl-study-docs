(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{309:function(n,o,s){"use strict";s.r(o);var e=s(14),a=Object(e.a)({},(function(){var n=this,o=n.$createElement,s=n._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"箭头函数-arrow-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数-arrow-function"}},[n._v("#")]),n._v(" 箭头函数 arrow function")]),n._v(" "),s("h3",{attrs:{id:"箭头函数的语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的语法"}},[n._v("#")]),n._v(" 箭头函数的语法")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("(参数1,参数2,...) => { 函数声明 }\n(参数1,参数2,...) => 表达式\n//当只有一个参数时，圆括号是可选的：\n(单一参数) => { 函数声明 }\n单一参数 => {函数声明 }\n//没有参数的函数应该写成一对圆括号。\n() => { 函数声明 }\n\n// 如果函数执行体只有一行代码，那么{}可以省略，并且他会默认将这行代码执行结果作为返回值\nnums.forEach(item => item%2===0)\n    .map(item => item*100)\n    .reduce((preValue,item) => preValue + item)\n// 只有一个代码且是对象的时候需要加上小括号\nlet bar = ()=>({name:'xxx',age:18})\n")])])]),s("h3",{attrs:{id:"箭头函数的注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的注意点"}},[n._v("#")]),n._v(" 箭头函数的注意点")]),n._v(" "),s("ol",[s("li",[n._v("箭头函数没有自己的this，它里面的this是继承外面的this")]),n._v(" "),s("li",[n._v("箭头函数没有arguments，取而代之用rest参数...解决")]),n._v(" "),s("li",[n._v("箭头函数没有原型属性")]),n._v(" "),s("li",[n._v("箭头函数不能用作Generator函数，不能使用yeild关键字")]),n._v(" "),s("li",[n._v("箭头函数不能使用new命令，因为：\n"),s("ol",[s("li",[n._v("没有自己的this，无法调用call，apply")]),n._v(" "),s("li",[n._v("没有自己的原型对象")]),n._v(" "),s("li",[n._v("不能用作构造函数")])])]),n._v(" "),s("li",[n._v("箭头函数的this指向是固定的，但是它的指向在定义的时候是确定不了的，它的指向是在运行的时候才能确定，它里面的this的指向，是看他外面的第一个普通函数的this指向谁，然后箭头函数的this就是指向这个普通函数的this。")])]),n._v(" "),s("h3",{attrs:{id:"箭头函数的this-指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的this-指向"}},[n._v("#")]),n._v(" 箭头函数的this 指向")]),n._v(" "),s("p",[n._v("箭头函数没有自己的this，它里面的this是继承外面的this")]),n._v(" "),s("p",[n._v("箭头函数的this指向是固定的，但是它的指向在定义的时候是确定不了的，它的指向是在运行的时候才能确定，它里面的this的指向，是看他外面的第一个普通函数的this指向谁，然后箭头函数的this就是指向这个普通函数的this。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var obj1={\n  name:'obj1',\n  foo:function(){\n    console.log(this);\n  },\n  bar:()=>{\n    console.log(this);\n  }\n}\nvar obj2={\n  name:'obj2'\n}\n\nobj1.bar(); // obj1\nobj2.bar(); // obj1\n")])])]),s("h3",{attrs:{id:"模拟网络请求的案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模拟网络请求的案例"}},[n._v("#")]),n._v(" 模拟网络请求的案例")]),n._v(" "),s("ul",[s("li",[n._v("使用 setTimeout 来模拟网络请求，请求到数据后如何可以放到data 中呢？")]),n._v(" "),s("li",[n._v("我们需要拿到 obj 对象，设置data")]),n._v(" "),s("li",[n._v("但是直接拿到的this 是window ，我们需要在外层定义：var _this = this")]),n._v(" "),s("li",[n._v("在setTimeout 的回调函数中使用 _this 就代表了 obj 对象")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('var obj={\n  data:[],\n  getData:function(){\n    var _this = this;\n    setTimeout(function(){\n      // 模拟获取到的数据\n      var res=["a","b","c"];\n      _this.data.push(...res);\n    },1000);\n  }\n}\n')])])]),s("p",[n._v("上面的例子中我们使用的ES5来实现的，是通过_this 变量来赋值的，接下来我们使用ES6的箭头函数来实现。")]),n._v(" "),s("ul",[s("li",[n._v("为什么在setTimeout 的回调函数中可以直接使用this尼？")]),n._v(" "),s("li",[n._v("因为箭头函数并不绑定 this 对象，那么this引用就会从上层作用域中找到对应的this")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('var obj={\n  data:[],\n  getData:function(){\n    setTimeout(()=>{\n      // 模拟获取到的数据\n      var res=["a","b","c"];\n      this.data.push(...res);\n    },1000);\n  }\n}\n')])])]),s("p",[n._v("如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this 指向谁尼？\n答案：window")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var obj={\n  data:[],\n  getData:()=>{\n    setTimeout(()=>{\n      console.log(this)\n    },1000);\n  }\n}\n")])])]),s("h3",{attrs:{id:"练习题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#练习题"}},[n._v("#")]),n._v(" 练习题")]),n._v(" "),s("p",[n._v("第一题：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('var name="window";\nvar person={\n  name:"person",\n  sayName:function(){\n    console.log(this.name);\n  }\n}\nfunction sayName(){\n  var ss=person.sayName;\n  ss();// window\n  person.sayName();// person\n  (person.sayName)();// person\n  (b = person.sayName)();// window\n}\nsayName();\n')])])]),s("p",[n._v("第二题：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var name='window';\nvar person1={\n  name:'person1',\n  foo1:function(){\n    console.log(this.name)\n  },\n  foo2:()=>console.log(this.name),\n  foo3:function(){\n    return function(){\n      console.log(this.name)\n    }\n  },\n  foo4:function(){\n    return ()=>{\n      console.log(this.name)\n    }\n  }\n}\n\nvar person2={name:'person2'}\n\nperson1.foo1();// person1\nperson1.foo1.call(person2); // person2\n\nperson1.foo2();// window\nperson1.foo2.call(person2); // window\n\nperson1.foo3()();// window\nperson1.foo3.call(person2)(); // window\nperson1.foo3().call(person2);// person2\n\nperson1.foo4()();// person1\nperson1.foo4.call(person2)(); // person2\nperson1.foo4().call(person2);// person1\n\n")])])]),s("p",[n._v("第三题：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var name='window'\nfunction Person(name){\n  this.name=name;\n  this.foo1=function (){\n    console.log(this.name)\n  }\n  this.foo2=()=>console.log(this.name)\n  this.foo3=function(){\n    return function(){\n      console.log(this.name)\n    }\n  }\n  this.foo4=function(){\n    return ()=>{\n      console.log(this.name)\n    }\n  }\n}\n\nvar person1=new Person('person1');\nvar person2=new Person('person2');\n\nperson1.foo1();//person1\nperson1.foo1().call(person2)//person2\n\nperson1.foo2();//person1\nperson1.foo2().call(person2)//person1\n\nperson1.foo3()();// window\nperson1.foo3.call(person2)(); // window\nperson1.foo3().call(person2);// person2\n\nperson1.foo4()();// person1\nperson1.foo4.call(person2)(); // person2\nperson1.foo4().call(person2);// person1\n")])])]),s("p",[n._v("第四题：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var name='window'\nfunction Person(name){\n  this.name=name\n  this.obj={\n    foo1:function(){\n      return function(){\n        console.log(this.name)\n      }\n    },\n    foo2:function(){\n      return ()=>{\n        console.log(this.name)\n      }\n    }\n  }\n}\n\nvar person1=new Person('person1');\nvar person2=new Person('person2');\n\nperson1.obj.foo1()();// window\nperson1.obj.foo1.call(person2)(); // window\nperson1.obj.foo1().call(person2);// person2\n\nperson1.obj.foo2()();// obj\nperson1.obj.foo2.call(person2)(); // person2\nperson1.obj.foo3().call(person2);// obj\n")])])])])}),[],!1,null,null,null);o.default=a.exports}}]);