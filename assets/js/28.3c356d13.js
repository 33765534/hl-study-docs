(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{308:function(n,r,a){"use strict";a.r(r);var t=a(14),s=Object(t.a)({},(function(){var n=this,r=n.$createElement,a=n._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"实现手写-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现手写-call"}},[n._v("#")]),n._v(" 实现手写 call")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 给所有的函数添加一个 hycall 方法\nFunction.prototype.myCall = function(thisArg, ...args) {\n    // 在这里可以去执行调用的哪个函数（sum）\n    // 这里的 this 就是调用 myCall 的函数，即 sum\n    // 1.获取需要被执行的函数\n    let fn = this;\n\n    // 2. 对thisArg 转成对象类型（防止传入的是非对象类型）\n    thisArg = thisArg ? Object(thisArg) : window;\n\n    // 3. 将调用函数的this 指向thisArg\n    thisArg.fn = fn;\n\n    // 4. 执行函数\n    let result = thisArg.fn(...args);\n\n    // 5. 删除fn\n    delete thisArg.fn;\n    // 6. 返回结果\n    return result;\n}\n\n\nfunction sum(num1,num2,num3,num4) {\n    console.log(num1,num2,num3,num4);\n}\n\nvar newSum = sum.myCall("aaa",10,20,30,40);\n')])])]),a("h2",{attrs:{id:"实现手写-apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现手写-apply"}},[n._v("#")]),n._v(" 实现手写 apply")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 给所有的函数添加一个 hyapply 方法\nFunction.prototype.myApply = function(thisArg,argArray){\n    // thisArg 如果是null 或者 undefined，那么默认指向window\n    thisArg = thisArg!==null && thisArg!==undefined ? Object(thisArg) : window;\n\n    // 将当前this == 当前函数赋值给thisArg的fn 属性\n    // 这样thisArg 就可以调用当前函数了\n    thisArg.fn = this;\n\n    // 当参宿和没有传的情况下 需要非空判断\n    argArray = argArray ? argArray : [];\n    let result = thisArg.fn(...argArray);\n\n    // 删除fn\n    delete thisArg.fn;\n    return result;\n}\n\nfunction sum(num1,num2,num3,num4) {\n    console.log(num1,num2,num3,num4);\n}\n\nvar newSum = sum.myApply("aaa",[10,20,30,40]);\n')])])]),a("h2",{attrs:{id:"实现手写-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现手写-bind"}},[n._v("#")]),n._v(" 实现手写 bind")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 给所有的函数添加一个 myBind 方法\nFunction.prototype.myBind = function(thisArg, ...argArray) {\n    // thisArg 如果是null 或者 undefined，那么默认指向window\n    thisArg = thisArg ? Object(thisArg) : window;\n    // 1. 获取调用bind的函数\n    thisArg.fn = this;\n    // 2. 返回一个函数\n    return function F(...arg) {\n        // 3. thisArg 执行函数并传入参数\n        var res=thisArg.fn(...[...argArray,...arg]);\n        delete thisArg.fn;\n        return res;\n    }\n}\n\nfunction sum(num1,num2,num3,num4) {\n    console.log(num1,num2,num3,num4);\n}\n\nvar newSum = sum.myBind("aaa",10);\nnewSum(20,30,40);\n\n')])])]),a("h2",{attrs:{id:"认识-arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#认识-arguments"}},[n._v("#")]),n._v(" 认识 arguments")]),n._v(" "),a("h3",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[n._v("#")]),n._v(" 特点")]),n._v(" "),a("ol",[a("li",[n._v("arguments是一个类数组对象，它包含传入函数中的所有参数")]),n._v(" "),a("li",[n._v("arguments 不是一个数组类型，但是它拥有数组的一些属性，例如 length，比如可以通过index索引来访问，但是它没有数组的一些方法，例如 forEach、map 等")]),n._v(" "),a("li",[n._v("arguments 对象还有一些属性，例如 callee 表示当前执行的函数，caller 表示调用当前函数的函数")])]),n._v(" "),a("h3",{attrs:{id:"箭头函数中没有arguments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数中没有arguments"}},[n._v("#")]),n._v(" 箭头函数中没有arguments")]),n._v(" "),a("p",[n._v("注：如果箭头函数中写了arguments，那么会去上层作用域找，如果找到最高层的全局作用域，在node环境中全局作用域是有arguments，浏览器的全局作用域中是没有arguments")]),n._v(" "),a("h3",{attrs:{id:"arguments转数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arguments转数组"}},[n._v("#")]),n._v(" arguments转数组")]),n._v(" "),a("ol",[a("li",[n._v("自己遍历")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo(num1,num2){\n    var newArray = [];\n    for(var i=0;i<arguments.length;i++){\n        newArray.push(arguments[i]);\n    }\n}\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[n._v("Array.prototype.slice 将 arguments 转换成数组")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var newArray = Array.prototype.slice.call(arguments);\n\nvar newArray2 = [].slice.call(arguments);\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[n._v("ES6 语法 Array.from 将 arguments 转换成数组")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var newArray3 = Array.from(arguments);\nvar newArray4 = [...arguments];// 扩展运算符\n")])])]),a("h3",{attrs:{id:"手写数组的slice方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写数组的slice方法"}},[n._v("#")]),n._v(" 手写数组的slice方法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Array.prototype.mySlice = function(start,end){\n    var arr = this\n    start = start || 0;\n    end = end || arr.length;\n    var newArray = [];\n    for(var i=start;i<end;i++){\n        newArray.push(arr[i]);\n    }\n    return newArray;\n}\n\nvar newArray = [1,2,3,4,5].mySlice(0,3);\nconsole.log(newArray);\n")])])])])}),[],!1,null,null,null);r.default=s.exports}}]);